scheme:
CCPS0000 LLLLLLLL
VVVVVVVV 00000000
    
RAM writes:
00PS0000 LLLLLLLL
VVVVVVVV 00000000
    
RAM writes with pointer
001S0000 LLLLLLLL
R START  R END   
OFFSET   VVVVVVVV



.word initial address
.word end address
lis r0, 0xinitial_address   // load initial address into r0
ori r0, 0xinitial_address
lis r1, 0xend_address       // load end address into r1
ori r1, 0xend_address
cmpw r0, r1                 // compare initial address with end address
bge- 0x14                   // if ture, then maximum amount of cheat codes has been reached. go to blr
lbz r2, 0 (r0)              // load code type value into r2
lbz r3, 0x4 (r0)            // load first byte of next word into r2
cmpw r2, r4                 // compare them
bne- 0x8                    // if they are not equal, go to 0x8
blr                         // if they are equal there aren't any cheats following. so go out of cheat managing for the current frame

cmpwi r2, 0x0000            // check if it's a RAM write code type
beq- 0xX                    // if true goto function to check if pointers are involved (lbz r3, 0x01 (r0))
nop                         // placeholder
nop
nop
nop
nop
nop
nop
nop
nop
nop
nop
nop
nop
nop
nop
nop
nop
nop
nop
nop
nop
nop
nop
nop
nop
nop
nop
nop
nop
nop
nop
nop
nop
nop
nop
nop
nop
nop
nop
nop
nop
nop
blr
    
lbz r3, 0x01 (r0)           // load pointer check and data size value into r3
cmpwi r3, 0x20              // compare it with 0x20 (to ensure whether it's a pointer-in-pointer code or not)
bge- 0xXX                   // if equal or greater than 0x20 then it's a pointer-in-pointer and branch to 0xXX to p-i-p write function
cmpwi r3, 0x10              // compare it with 0x10 (to ensure whether it's a pointer code or not)
bge- 0x54                   // if equal or greater than 0x10 then it's a pointer and branch by 0x54 to pointer write function
cmpwi r3, 0x00              // check data type for 8bit
beq- 0x10                   // if equal, goto 0x10
cmpwi r3, 0x01              // else check data type for 16bit
beq- 0x1C                   // if equal goto 0x1C to 16bit function
b 0x2C                      // else goto 32bit function since otherwise it only can be this value type
    
//--- 8bit RAM write function ---    
lwz r3, 0x04 (r0)           // load address of cheat code into r3
lbz r4, 0x0B (r0)           // load byte/8bit value of cheat code into r4
stb r4, 0 (r3)              // write cheat code
addi r0, 0x10               // add 0x10 to initial address value to read from next cheat code
b 0x_load_end_address       // go back to 'load end address' to execute next cheat code
    
//--- 16bit RAM write function ---    
lwz r3, 0x04 (r0)           // load address of cheat code into r3
lhz r4, 0x0A (r0)           // load half word/16bit value of cheat code into r4
sth r4, 0 (r3)              // write cheat code
addi r0, 0x10               // add 0x10 to initial address value to read from next cheat code
b 0x_load_end_address       // go back to 'load end address' to execute next cheat code
    
//--- 32bit RAM write function ---
lwz r3, 0x04 (r0)           // load address of cheat code into r3
lwz r4, 0x08 (r0)           // load half word/16bit value of cheat code into r4
stw r4, 0 (r3)              // write cheat code
addi r0, 0x10               // add 0x10 to initial address value to read from next cheat code
b 0x_load_end_address       // go back to 'load end address' to execute next cheat code
 
    
    
//--- check datasize of pointers ---
cmpwi r3, 0x10              // check data type for 8bit
beq- 0x10                   // if equal, goto 0x10
cmpwi r3, 0x11              // else check data type for 16bit
beq- 0x40                   // if equal goto 0x40 to 16bit function
b 0x74                      // else goto 32bit function since otherwise it only can be this value type   
      
//--- 8bit pointer write function ---
lwz r3, 0x4 (r0)            // load pointer location into r3
lwz r3, 0 (r3)              // load pointer address/value into r3
lwz r4, 0x08 (r0)           // load range start into r4
lwz r5, 0x0C (r0)           // load range end into r5
cmpw r3, r4                 // compare pointer with range start
blt- 0xXXXXXXXXXXX          // abort
cmpw r3, r5                 // compare pointer with range end
bgt- 0xXXXXXXXXXX           // abort
lwz r4, 0x10 (r0)           // load offset into r4
add r3, r3, r4              // add pointer with offset and store into r3
lbz r4, 0x17                // load byte
stb r4, 0 (r3)              // store cheat value
addi r0, 0x18               // add 0x18 to initial address value to read from next cheat code
b 0x_load_end_address       // go back to 'load end address' to execute next cheat code
    
//--- 16bit pointer write function ---
lwz r3, 0x4 (r0)            // load pointer location into r3
lwz r3, 0 (r3)              // load pointer address/value into r3
lwz r4, 0x08 (r0)           // load range start into r4
lwz r5, 0x0C (r0)           // load range end into r5
cmpw r3, r4                 // compare pointer with range start
blt- 0xXXXXXXXXXXX          // abort
cmpw r3, r5                 // compare pointer with range end
bgt- 0xXXXXXXXXXX           // abort
lwz r4, 0x10 (r0)           // load offset into r4
add r3, r3, r4              // add pointer with offset and store into r3
lhz r4, 0x16                // load half word
sth r4, 0 (r3)              // store cheat value
addi r0, 0x18               // add 0x18 to initial address value to read from next cheat code
b 0x_load_end_address       // go back to 'load end address' to execute next cheat code   
    
//--- 32bit pointer write function ---
lwz r3, 0x4 (r0)            // load pointer location into r3
lwz r3, 0 (r3)              // load pointer address/value into r3
lwz r4, 0x08 (r0)           // load range start into r4
lwz r5, 0x0C (r0)           // load range end into r5
cmpw r3, r4                 // compare pointer with range start
blt- 0xXXXXXXXXXXX          // abort
cmpw r3, r5                 // compare pointer with range end
bgt- 0xXXXXXXXXXX           // abort
lwz r4, 0x10 (r0)           // load offset into r4
add r3, r3, r4              // add pointer with offset and store into r3
lhz r4, 0x14                // load word
stw r4, 0 (r3)              // store cheat value
addi r0, 0x18               // add 0x18 to initial address value to read from next cheat code
b 0x_load_end_address       // go back to 'load end address' to execute next cheat code    
    
    
Â©CosmoCortney
    

'0xXX' means that the offset is yet not determined because the code size may change. Same for b 0x_load_end_address.
