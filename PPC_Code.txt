

// all cheat codes are stored in range 10015000 - 10017000. This area is always filled with zeros (need to veryfy if this is the case during loading times). Offers space for 2048 lines of cheat codes.
// register 5 is fuggitive and can be overwritten without worries
// r0 mustn't be touched. Loading or writing to an address into there will freeze the system
// r6 is used for the start of the cheat code table (0x10015000 )
// r7 is used for the end of the cheat code table (0x10017000)

.word 0x10015000            // start address
.word 0x10017000            // end address
    
0xA11AE1f4                  // Actual code handler starts here  

lwz r29,852(r1)             // Original instruction that is over written by 'b 0x5E9E0' at 0xA114F820 which mustn't be lost
lis r5, 0xA11A              // Load address 0xA11AE100 into r5 because r0 - r7 and f0 - f4 will be backed up there
ori r5, r5, 0xE100
stw r8, 0x30 (r5)           // backup r8
stw r9, 0x34 (r5)           // backup r9
stw r10, 0x38 (r5)          // backup r10
stw r0, 0x0 (r5)            // backup r0
stw r1, 0x04 (r5)           // backup r1
stw r2, 0x08 (r5)           // backup r2
stw r3, 0x0C (r5)           // backup r3
stw r4, 0x10 (r5)           // backup r4
stw r5, 0x14 (r5)           // backup r5
stw r6, 0x18 (r5)           // backup r6
stw r7, 0x1C (r5)           // backup r7
stfs f0, 0x20 (r5)          // backup f0
stfs f1, 0x24 (r5)          // backup f1
stfs f2, 0x28 (r5)          // backup f2
stfs f3, 0x2C (r5)          // backup f3
lis r6, 0x1001              // load initial address into r6
ori r6, r6, 0x5000  
lis r7, 0x1001              // load end address into r7
ori r7, r7, 0x7000
cmpw r6, r7                 // compare initial address with end address
bge- 0x14                   // if ture, then maximum amount of cheat codes has been reached. go to abortion
lbz r1, 0 (r6)              // load code type value into r1
lbz r2, 0x4 (r6)            // load first byte of next word into r2
cmpw r1, r2                 // compare them
bne- 0x8                    // if they are not equal, go to 0x8
b 0xA11B0E00                // if they are equal there aren't any cheats following. so go out of cheat managing for the current frame

cmpwi r1, 0x00              // check if it's a RAM write code type
beq- 0xA11B1000             // if true goto function to check if pointers are involved (lbz r2, 0x01 (r6))
cmpwi r1, 0x01              // check if it's a patch/fill write code type
beq- 0xA11B0C00             // if true goto function to check if pointers are involved (lbz r2, 0x01 (r6))  
cmpwi r1, 0x02              // check if it's a skip/slide write code type
beq- 0xA11B0800             // if true goto function to check if pointers are involved 
nop                         // placeholder
nop
b 0xA11B0E00                // if there is anything else then it's no code type and go to abortion
    

//0xA11B01000
lbz r2, 0x01 (r6)           // load pointer check and data size value into r2
cmpwi r2, 0x20              // compare it with 0x20 (to ensure whether it's a pointer-in-pointer code or not)
bge- 0xA11B1120                  // if equal or greater than 0x20 then it's a pointer-in-pointer and branch to 0xXX to p-i-p write function
cmpwi r2, 0x10              // else compare it with 0x10 (to ensure whether it's a pointer code or not)
bge- 0x54                   // if equal or greater than 0x10 then it's a pointer and branch by 0x54 to pointer write function
cmpwi r2, 0x00              // else it must be a normal RAM write. check data type for 8bit
beq- 0x10                   // if equal, goto 0x10
cmpwi r2, 0x01              // else check data type for 16bit
beq- 0x1C                   // if equal goto 0x1C to 16bit function
b 0x2C                      // else goto 32bit function it can only be this value type now
    
//--- 8bit RAM write function ---    
lwz r3, 0x04 (r6)           // load address of cheat code into r3
lbz r4, 0x0B (r6)           // load byte/8bit value of cheat code into r4
stb r4, 0 (r3)              // write cheat code
addi r6, r6, 0x10               // add 0x10 to initial address value to read from next cheat code
b b 0xa11ae244              // go back to 'load end address' to execute next cheat code
    
//--- 16bit RAM write function ---    
lwz r3, 0x04 (r6)           // load address of cheat code into r3
lhz r4, 0x0A (r6)           // load half word/16bit value of cheat code into r4
sth r4, 0 (r3)              // write cheat code
addi r6, 0x10               // add 0x10 to initial address value to read from next cheat code
b b 0xa11ae244              // go back to 'load end address' to execute next cheat code
    
//--- 32bit RAM write function ---
lwz r3, 0x04 (r6)           // load address of cheat code into r3
lwz r4, 0x08 (r6)           // load half word/16bit value of cheat code into r4
stw r4, 0 (r3)              // write cheat code
addi r6, 0x10               // add 0x10 to initial address value to read from next cheat code
b b 0xa11ae244              // go back to 'load end address' to execute next cheat code
 
    
    
//--- check datasize of pointers ---
cmpwi r2, 0x10              // check data type for 8bit
beq- 0x10                   // if equal, goto 0x10
cmpwi r2, 0x11              // else check data type for 16bit
beq- 0x40                   // if equal goto 0x40 to 16bit function
b 0x74                      // else goto 32bit function since otherwise it only can be this value type   
      
//--- 8bit pointer write function ---
lwz r2, 0x4 (r6)            // load pointer location into r2
lwz r2, 0 (r2)              // load pointer address/value into r2
lwz r3, 0x08 (r6)           // load range start into r3
lwz r4, 0x0C (r6)           // load range end into r4
cmpw r2, r3                 // compare pointer with range start
blt- 0xa11b10a8             // abort goto add 0x18
cmpw r2, r4                 // compare pointer with range end
bgt- 0xa11b10a8             // abort goto add 0x18
lwz r3, 0x10 (r6)           // load offset into r3
add r2, r2, r3              // add pointer with offset and store into r2
lbz r3, 0x17 (r6)           // load byte into r3
stb r3, 0 (r2)              // store cheat value
addi r6, r6, 0x18           // add 0x18 to initial address value to read from next cheat code
b 0xa11ae244                // go back to 'load end address' to execute next cheat code
    
//--- 16bit pointer write function ---
lwz r2, 0x4 (r6)            // load pointer location into r2
lwz r2, 0 (r2)              // load pointer address/value into r2
lwz r3, 0x08 (r6)           // load range start into r3
lwz r4, 0x0C (r6)           // load range end into r4
cmpw r2, r3                 // compare pointer with range start
blt- 0xa11b10E0             // abort goto add 0x18
cmpw r2, r4                 // compare pointer with range end
bgt- 0xa11b10E0             // abort goto add 0x18
lwz r3, 0x10 (r6)           // load offset into r3
add r2, r2, r3              // add pointer with offset and store into r2
lhz r3, 0x16 (r6)           // load half word into r3
sth r3, 0 (r2)              // store cheat value
addi r6, r6, 0x18           // add 0x18 to initial address value to read from next cheat code
b 0xa11ae244                // go back to 'load end address' to execute next cheat code 
    
//--- 32bit pointer write function ---
lwz r2, 0x4 (r6)            // load pointer location into r2
lwz r2, 0 (r2)              // load pointer address/value into r2
lwz r3, 0x08 (r6)           // load range start into r3
lwz r4, 0x0C (r6)           // load range end into r4
cmpw r2, r3                 // compare pointer with range start
blt- 0xa11b10XX             // abort goto add 0x18
cmpw r2, r4                 // compare pointer with range end
bgt- 0xa11b10XX             // abort goto add 0x18
lwz r3, 0x10 (r6)           // load offset into r3
add r2, r2, r3              // add pointer with offset and store into r2
lwz r3, 0x14 (r6)           // load half word into r3
stw r3, 0 (r2)              // store cheat value
addi r6, r6, 0x18           // add 0x18 to initial address value to read from next cheat code
b 0xa11ae244                // go back to 'load end address' to execute next cheat code 
    

    
//--- check datasize of pointer-in-pointer ---
cmpwi r2, 0x20              // check data type for 8bit
beq- 0x10                   // if equal, goto 0x10
cmpwi r2, 0x21              // else check data type for 16bit
beq- 0xa11b1190/0x64        // if equal goto 0x40 to 16bit function
b 0xXX                      // else goto 32bit function since otherwise it only can be this value type   
      
//--- 8bit pointer-in-pointer write function ---
lwz r2, 0x4 (r6)            // load pointer location into r2
lwz r2, 0 (r2)              // load pointer/address/value into r2
lwz r3, 0x08 (r6)           // load range start into r3
lwz r4, 0x0C (r6)           // load range end into r4
cmpw r2, r3                 // compare pointer with range start
blt- 0xA11B1188             // abort goto add 0x18
cmpw r2, r4                 // compare pointer with range end
bgt- 0xA11B1188             // abort goto add 0x18
lwz r3, 0x10 (r6)           // load offset into r3
add r2, r2, r3              // add pointer with offset and store into r2
lwz r2, 0 (r2)              // load second pointer into r2    
lwz r3, 0x18 (r6)           // load second range start into r3
lwz r4, 0x1C (r6)           // load second range end into r4
cmpw r2, r3                 // compare pointer with range start
blt- 0xA11B1188             // abort goto add 0x18
cmpw r2, r4                 // compare pointer with range end
bgt- 0xA11B1188             // abort goto add 0x18   
lwz r3, 0x20 (r6)           // load offset into r3
add r2, r2, r3              // add pointer with offset and store into r2
lbz r3, 0x27 (r6)           // load byte into r3
stb r3, 0 (r2)              // store cheat value
addi r6, r6, 0x28           // add 0x18 to initial address value to read from next cheat code
b 0xa11ae244                // go back to 'load end address' to execute next cheat code    
    
//--- 16bit pointer-in-pointer write function ---
lwz r2, 0x4 (r6)            // load pointer location into r2
lwz r2, 0 (r2)              // load pointer/address/value into r2
lwz r3, 0x08 (r6)           // load range start into r3
lwz r4, 0x0C (r6)           // load range end into r4
cmpw r2, r3                 // compare pointer with range start
blt- 0xA11B11E4             // abort goto add 0x18
cmpw r2, r4                 // compare pointer with range end
bgt- 0xA11B11E4             // abort goto add 0x18
lwz r3, 0x10 (r6)           // load offset into r3
add r2, r2, r3              // add pointer with offset and store into r2
lwz r2, 0 (r2)              // load second pointer into r2    
lwz r3, 0x18 (r6)           // load second range start into r3
lwz r4, 0x1C (r6)           // load second range end into r4
cmpw r2, r3                 // compare pointer with range start
blt- 0xA11B11E4             // abort goto add 0x18
cmpw r2, r4                 // compare pointer with range end
bgt- 0xA11B11E4             // abort goto add 0x18   
lwz r3, 0x20 (r6)           // load offset into r3
add r2, r2, r3              // add pointer with offset and store into r2
lhz r3, 0x26 (r6)           // load byte into r3
sth r3, 0 (r2)              // store cheat value
addi r6, r6, 0x28           // add 0x18 to initial address value to read from next cheat code
b 0xa11ae244                // go back to 'load end address' to execute next cheat code   
    
    
  //--- 32bit pointer-in-pointer write function ---
lwz r2, 0x4 (r6)            // load pointer location into r2
lwz r2, 0 (r2)              // load pointer/address/value into r2
lwz r3, 0x08 (r6)           // load range start into r3
lwz r4, 0x0C (r6)           // load range end into r4
cmpw r2, r3                 // compare pointer with range start
blt- 0xA11B1240             // abort goto add 0x18
cmpw r2, r4                 // compare pointer with range end
bgt- 0xA11B1240             // abort goto add 0x18
lwz r3, 0x10 (r6)           // load offset into r3
add r2, r2, r3              // add pointer with offset and store into r2
lwz r2, 0 (r2)              // load second pointer into r2    
lwz r3, 0x18 (r6)           // load second range start into r3
lwz r4, 0x1C (r6)           // load second range end into r4
cmpw r2, r3                 // compare pointer with range start
blt- 0xA11B1240             // abort goto add 0x18
cmpw r2, r4                 // compare pointer with range end
bgt- 0xA11B1240             // abort goto add 0x18   
lwz r3, 0x20 (r6)           // load offset into r3
add r2, r2, r3              // add pointer with offset and store into r2
lwz r3, 0x24 (r6)           // load byte into r3
stw r3, 0 (r2)              // store cheat value
addi r6, r6, 0x28           // add 0x18 to initial address value to read from next cheat code
b 0xa11ae244                // go back to 'load end address' to execute next cheat code  
    
    
//--- A11B0C00 fill patch write
lbz r1, 0x01 (r6)           //load pointer byte
cmpwi r1, 0x10               // check if it's a pointer
beq- 0xXXXX                 // if true, goto 0xXX
lhz r1, 0x02 (r6)           // else no pointer and load amount of bytes to write
lwz r3, 0x04 (r6)           // load address of cheat into r3
lis r2, 0                   // clear r2 for counter
addi r6, r6, 0x07           // fix counts
subi r3, r3, 0x01           // fix counts
addi r2, r2, 0x01           // increase r2 by 1
addi r3, r3, 0x01           // increase cheat address by 1
addi r6, r6, 0x01           // increase start address by 1
lbz r4, 0 (r6)              // load byte of increased index into r4
stb r4, 0 (r3)              // store cheat
cmpw r1, r2                 // check if counter equals amount of bytes in cheat
bne- 0xA11B0C20             // goto addi r2, r2, 0x01 
addi r6, r6, 0x01           // increase start address by 1
lbz r2, 0 (r6)              // fill
cmpwi r2, 0xFF              // fill
bne- -0x0C                  // fill 
addi r6, r6, 0x01           // fix "start address"
b 0xa11ae244                // go back to 'load end address' to execute next cheat code  
    
    
    
    
// --- fill patch write    pointer  A11B0C54
lhz r1, 0x02 (r6)           // load amount of bytes to write
lwz r3, 0x04 (r6)           // load address of cheat into r3
lwz r3, 0 (r3)              // load pointer into r3
    
lwz r2, 0x08 (r6)           // load start range
lwz r4, 0x0C (r6)           // load end range
cmpw r3, r2
blt- 0xa11ae244 
cmpw r3, r4
bgt- 0xa11ae244 

lwz r2, 0x10 (r6)           // load offset
add r3, r3, r2              // add offset to address
lis r2, 0                   // clear r2 for counter
addi r6, r6, 0x17           // fix counts
subi r3, r3, 0x01           // fix counts
addi r2, r2, 0x01           // increase r2 by 1
addi r3, r3, 0x01           // increase cheat address by 1
addi r6, r6, 0x01           // increase start address by 1
lbz r4, 0 (r6)              // load byte of increased index into r4
stb r4, 0 (r3)              // store cheat
cmpw r1, r2                 // check if counter equals amount of bytes in cheat
bne- 0xA11B0C20             // goto addi r2, r2, 0x01 
addi r6, r6, 0x01           // increase start address by 1
lbz r2, 0 (r6)              // fill
cmpwi r2, 0xFF              // fill
bne- -0x0C                  // fill 
addi r6, r6, 0x01           // fix "start address"
b 0xa11ae244                // go back to 'load end address' to execute next cheat code  
  
addi r6, r6, 0x17           // fix counts A11B0CC0
add r6, r6, r1
addi r6, r6, 0x01           // increase start address by 1
lbz r2, 0 (r6)              // fill
cmpwi r2, 0xFF              // fill
   bne- -0x0C   
addi r6, r6, 0x01           // fix "start address"    
b 0xa11ae244                // go back to 'load end address' to execute next cheat code  
    
//--- 0xA11B0800 skip/slide write function pointer check
lbz r1, 1 (r6)
cmpwi r1, 0x10
bge- 0xA11B090C
    
cmpwi r1, 0x02
beq- 0xA11B08BC             // branch to 32bit function
cmpwi r1, 0x01              // else
beq- 0xA11B086C             // branch to 16bit function
 
    // 8bit
lhz r1, 0x02 (r6)            // else 8bit function. load number of skip writes into r1
lwz r2, 0x04 (r6)            // load cheat's address into r2
lbz r3, 0x0B (r6)            // load cheat value into r3
lwz r4, 0x0C (r6)            // load offset into r4
lbz r7, 0x13 (r6)            // load increment into r7
lis r8, 0x00                // set counter 
lwz r9, 0x04 (r6)           // back up cheat address___________________________________________  
addi r8, r8, 0x01           // add 1 to counter
cmpw r2, r9                 // check if cheat address has already increased
bne- 0x10
stb r3, 0 (r2)              // write first skip write's value
add r2, r2, r4              // add offset (r4) to cheat's address (r2) into r2
b -0x14                     // go write function
add r3, r3, r7              // add increment to value
stb r3, 0 (r2)              // write cheat value to increased address
add r2, r2, r4              // add offset (r4) to cheat's address (r2) into r2
cmpw r1, r8                 // check if counter has reach amount of writes
bne- -0x28                  // if untrue, next count
addi r6, r6, 0x18           // increase r6 to be able to read the next cheat in the list
b 0xa11ae244                // go back to 'load end address' to execute next cheat code 
    

    // 16bit
lhz r1, 0x02 (r6)            // load number of skip writes into r1
lwz r2, 0x04 (r6)            // load cheat's address into r2
lhz r3, 0x0A (r6)            // load cheat value into r3
lwz r4, 0x0C (r6)            // load offset into r4
lhz r7, 0x12 (r6)            // load increment into r7
lis r8, 0x00                // set counter 
lwz r9, 0x04 (r6)           // back up cheat address___________________________________________  
addi r8, r8, 0x01           // add 1 to counter
cmpw r2, r9                 // check if cheat address has already increased
bne- 0x10
sth r3, 0 (r2)              // write first skip write's value
add r2, r2, r4              // add offset (r4) to cheat's address (r2) into r2
b -0x14                     // go write function
add r3, r3, r7              // add increment to value
sth r3, 0 (r2)              // write cheat value to increased address
add r2, r2, r4              // add offset (r4) to cheat's address (r2) into r2
cmpw r1, r8                 // check if counter has reach amount of writes
bne- -0x28                  // if untrue, next write
addi r6, r6, 0x18           // increase r6 to be able to read the next cheat in the list
b 0xa11ae244                // go back to 'load end address' to execute next cheat code 
    
    
    // 32bit
lhz r1, 0x02 (r6)            // load number of skip writes into r1
lwz r2, 0x04 (r6)            // load cheat's address into r2
lwz r3, 0x08 (r6)            // load cheat value into r3
lwz r4, 0x0C (r6)            // load offset into r4
lwz r7, 0x10 (r6)            // load increment into r7
lis r8, 0x00                // set counter 
lwz r9, 0x04 (r6)           // back up cheat address___________________________________________  
addi r8, r8, 0x01           // add 1 to counter
cmpw r2, r9                 // check if cheat address has already increased
bne- 0x10
stw r3, 0 (r2)              // write first skip write's value
add r2, r2, r4              // add offset (r4) to cheat's address (r2) into r2
b -0x14                     // go write function
add r3, r3, r7              // add increment to value
stw r3, 0 (r2)              // write cheat value to increased address
add r2, r2, r4              // add offset (r4) to cheat's address (r2) into r2
cmpw r1, r8                 // check if counter has reach amount of writes
bne- -0x28                  // if untrue, next write
addi r6, r6, 0x18           // increase r6 to be able to read the next cheat in the list
b 0xa11ae244                // go back to 'load end address' to execute next cheat code     
    
    
 // pointer skip writes
cmpwi r1, 0x12
beq- 0xA11B0A1C            // branch to 32bit function
cmpwi r1, 0x11              // else
beq- 0xA11B099C            // branch to 16bit function
 
    // 8bit
lhz r1, 0x02 (r6)            // else 8bit function. load number of skip writes into r1
lwz r2, 0x04 (r6)            // load cheat's address into r2
lwz r2, 0 (r2)            // load pointer into r2
lwz r3, 0x08 (r6)            // load start range into r3
lwz r4, 0x0C (r6)            // load end range into r4
cmpw r2, r3
blt- 0xA11B0994             // if true abort to "addi r6, r6, 0x20"
cmpw r2, r4
bgt- 0xA11B0994            // if true abort to "addi r6, r6, 0x20"
lwz r3, 0x10 (r6)           // load pointer offset into r3
add r2, r2, r3              // add pointer with address   
    
lbz r3, 0x17 (r6)            // load cheat value into r3
lwz r4, 0x18 (r6)            // load inc-offset into r4
lbz r7, 0x1F (r6)            // load increment into r7
lis r8, 0x00                // set counter 
lwz r9, 0x04 (r6)            // load cheat's address into r9_______________________________________ 
lwz r9, 0 (r9)           // load pointer
lwz r10, 0x10 (r6)          // load pointer offset into r10
add r9, r9, r10             // back up pointer + offset___________________________________________  
addi r8, r8, 0x01           // add 1 to counter
cmpw r2, r9                 // check if cheat address has already increased
bne- 0x10
stb r3, 0 (r2)              // write first skip write's value
add r2, r2, r4              // add offset (r4) to cheat's address (r2) into r2
b -0x14                     // go back to write function
add r3, r3, r7              // add increment to value
stb r3, 0 (r2)              // write cheat value to increased address
add r2, r2, r4              // add offset (r4) to cheat's address (r2) into r2
cmpw r1, r8                 // check if counter has reach amount of writes
bne- -0x28                  // if untrue, next count
addi r6, r6, 0x20           // increase r6 to be able to read the next cheat in the list
b 0xa11ae244                // go back to 'load end address' to execute next cheat code 
   
    
    
  
    // 16bit
lhz r1, 0x02 (r6)            // else 16bit function. load number of skip writes into r1
lwz r2, 0x04 (r6)            // load cheat's address into r2
lwz r2, 0 (r2)            // load pointer into r2
lwz r3, 0x08 (r6)            // load start range into r3
lwz r4, 0x0C (r6)            // load end range into r4
cmpw r2, r3
blt- 0xA11B0A14             // if true abort to "addi r6, r6, 0x20"
cmpw r2, r4
bgt- 0xA11B0A14              // if true abort to "addi r6, r6, 0x20"
lwz r3, 0x10 (r6)           // load pointer offset into r3
add r2, r2, r3              // add pointer with offset   
    
lhz r3, 0x16 (r6)            // load cheat value into r3
lwz r4, 0x18 (r6)            // load inc-offset into r4
lhz r7, 0x1E (r6)            // load increment val into r7
lis r8, 0x00                // set counter 
lwz r9, 0x04 (r6)            // load cheat's address into r9_______________________________________    
lwz r9, 0 (r9)           // load pointer
lwz r10, 0x10 (r6)          // load pointer offset into r10
add r9, r9, r10             // back up pointer + offset___________________________________________  
addi r8, r8, 0x01           // add 1 to counter
cmpw r2, r9                 // check if cheat address has already increased
bne- 0x10
sth r3, 0 (r2)              // write first skip write's value
add r2, r2, r4              // add offset (r4) to cheat's address (r2) into r2
b -0x14                     // go back to write function
add r3, r3, r7              // add increment to value
sth r3, 0 (r2)              // write cheat value to increased address
add r2, r2, r4              // add offset (r4) to cheat's address (r2) into r2
cmpw r1, r8                 // check if counter has reach amount of writes
bne- -0x28                  // if untrue, next count
addi r6, r6, 0x20           // increase r6 to be able to read the next cheat in the list
b 0xa11ae244                // go back to 'load end address' to execute next cheat code    
    
    
 
    // 32bit
lhz r1, 0x02 (r6)            // else 32bit function. load number of skip writes into r1
lwz r2, 0x04 (r6)            // load cheat's address into r2
lwz r2, 0 (r2)            // load pointer into r2
lwz r3, 0x08 (r6)            // load start range into r3
lwz r4, 0x0C (r6)            // load end range into r4
cmpw r2, r3
blt- 0xA11B0A94             // if true abort to "addi r6, r6, 0x20"
cmpw r2, r4
bgt- 0xA11B0A94             // if true abort to "addi r6, r6, 0x20"
lwz r3, 0x10 (r6)           // load pointer offset into r3
add r2, r2, r3              // add pointer with address   
    
lwz r3, 0x14 (r6)            // load cheat value into r3
lwz r4, 0x18 (r6)            // load inc-offset into r4
lwz r7, 0x1C (r6)            // load increment into r7
lis r8, 0x00                // set counter 
lwz r9, 0x04 (r6)            // load cheat's address into r9_______________________________________  
lwz r9, 0 (r9)           // load pointer
lwz r10, 0x10 (r6)          // load pointer offset into r10
add r9, r9, r10             // back up pointer + offset___________________________________________  
addi r8, r8, 0x01           // add 1 to counter
cmpw r2, r9                 // check if cheat address has already increased
bne- 0x10
stW r3, 0 (r2)              // write first skip write's value
add r2, r2, r4              // add offset (r4) to cheat's address (r2) into r2
b -0x14                     // go back to write function
add r3, r3, r7              // add increment to value
stW r3, 0 (r2)              // write cheat value to increased address
add r2, r2, r4              // add offset (r4) to cheat's address (r2) into r2
cmpw r1, r8                 // check if counter has reach amount of writes
bne- -0x28                  // if untrue, next count
addi r6, r6, 0x20           // increase r6 to be able to read the next cheat in the list
b 0xa11ae244                // go back to 'load end address' to execute next cheat code     
    
    .
    .
    .
    
//A11B0E00 
lwz r0, 0x0 (r5)            // restore r0
lwz r1, 0x04 (r5)           // restore r1
lwz r2, 0x08 (r5)           // restore r2
lwz r3, 0x0C (r5)           // restore r3
lwz r4, 0x10 (r5)           // restore r4
lwz r5, 0x14 (r5)           // restore r5
lwz r6, 0x18 (r5)           // restore r6
lwz r7, 0x1C (r5)           // restore r7
lfs f0, 0x20 (r5)           // restore f0
lfs f1, 0x24 (r5)           // restore f1
lfs f2, 0x28 (r5)           // restore f2
lfs f3, 0x2C (r5)           // restore f3
lwz r8, 0x30 (r5)           // restore r8
lwz r9, 0x34 (r5)           // restore r9
lwz r10, 0x38 (r5)          // restore r10
A11B0E30 b 0xa114f824       // exit code handler and go back
    
    
A114F820 b 0x5E8E0          // Hook at 0xA114F820. 'b 0x5E8E0' must be written last

©CosmoCortney
    

'0xXX' means that the offset is yet not determined because the code size may change. Same for b 0x_load_end_address.
